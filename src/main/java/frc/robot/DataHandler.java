package frc.robot;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.IOError;
import java.util.ArrayList;
import java.util.List;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
/**
 * Class used for logging data. Coded as an alternative to DataLogManager (so
 * you don't get every update in NetworkTables logged, just the values you
 * want), designed to be used for polynomial regression. Saves data in columns
 * instead of rows (each value for x is represented by the values below it) Used
 * in conjunction with
 * https://colab.research.google.com/drive/1pj7j6u2x-s2kY2aWgmiyc5_2wwpUgusc to
 * output a (somewhat) accurate polynomial model linking 2 variables together.
 * Can also be used as a way to save values from the RIO to a .txt file. To use
 * this with the polynomial regression tool, delete all files in the
 * "sample_data" folder, upload your files to the "sample_data" folder, and run
 * the tool. You will need some knowledge in regression (r squared, residuals,
 * etc) to interpret the result.
 */
public class DataHandler {
	private static FileOutputStream outputStream;
	private static OutputStreamWriter outputStreamWriter;
	private static int id = 0;
	private static List<String> dataBuffer = new ArrayList<String>();
	private static String diskName = "/U";
	private static String directoryName = "";
	private static File createdFile;
	private static File directory;
	public static boolean isUSBConnected = true;
	public static boolean fileCreated = false;
	private static int debounce = 0;
	private static int dumpID = 1;
	@SuppressWarnings("unused")
	private static boolean useNetworkTables;
	/**
	 * Creates a new Streamwriter, designed to be contingent in case of USB
	 * disconnection and reconnection
	 */
	public static void createNewWriter() {
		try {
			outputStream = new FileOutputStream(createdFile);
		}
		catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		outputStreamWriter = new OutputStreamWriter(outputStream);
	}
	
	/**
	 * This function allows you to customize the directory that you send a log to
	 * in simulation. Designed to be used for simulations or other applications
	 * where the directory to be sent to is different from the default roboRIO
	 * USB Directory. All other functions in this class should work with the log
	 * and reader generated by this function.
	 * 
	 * @param directory The folder where the simulated log will be written. Will
	 *                     need to be changed based on the device you're running
	 *                     simulation from and the directory where the logs are
	 *                     recorded.
	 * @see DataHandler
	 */
	public static void setSimDisk(String directory){
		DataHandler.directoryName = directory;
	}

	/**
	 * Call this in Robot.java. Starts the handler and has contingencies to use the NetworkTables, write to usb, or write to a sim disk drive
	 * @param useNetworkTables
	 * A boolean that states whether to write to a physical USB or use the networktables
	 * @param simDiskName
	 * A string that states what disk to write to in simulation
	 */
	public static void startHandler(boolean useNetworkTables, String simDiskDirectory){
		DataHandler.useNetworkTables = useNetworkTables;
		if (useNetworkTables){
			SmartDashboard.putString("DataHandler","initialized!");
		}
		else {
			if (Robot.isReal()){
				createLogFileOnRIOUSB();
			}else{
				setSimDisk(simDiskDirectory);
				createLogFileOnRIOUSB();
			}
		}
			
		}


	



	/**
	 * Creates a file on a folder called "logs" (located on the USB attached to
	 * the rio) to log all values to. If there is no folder called "logs", it
	 * creates a folder. Only call one time (either in RobotInit or a subsystem
	 * constructor). Using this function in simulation (instead of
	 * createLogFileInSimulation) will lead to an IOException of "the system
	 * cannot find the path specified". Use createLogFileInSimulation with a
	 * specific directory given to run this in simulation If no USB drive is
	 * present, will just throw an error and not create a file. Only include the
	 * drive and the colon (C:), NOT C://
	 */
	public static void createLogFileOnRIOUSB() {
		// "/U" is the default directory (drive name) for RoboRIO flash drives, create a new folder called "/U/Logs" if one doesn't exist
		//function based off of https://github.com/HoyaRobotics/InfiniteRecharge2020/blob/master/src/main/java/frc/robot/util/Logger.java
		//Creates the logs file in the specified drive if none is there
		directoryName = diskName + "/Logs";
		directory = new File(directoryName);
		//This code isn't TECHNICALLY needed to make the directory (it auto checks if a folder is there), but i would like to make sure this is here just in case something happens
		if (!directory.exists()) {
			directory.mkdir();
		}
		try {
			//Creates new file in the /U/Logs folder 
			String fileName = directoryName + "/Latest.txt";
			createdFile = new File(fileName);
			//if a file named "latest" exists, rename "latest" to the id in its first line
			if (createdFile.exists()) {
				Scanner renameScanner = new Scanner(createdFile);
				if (renameScanner.hasNext()) {
					try {
						id = Integer.parseInt(renameScanner.nextLine());
					}
					catch (Exception e) {
						System.out.println("ID did not exist, using default" + id);
					}
					renameScanner.close();
				}
				//Create the new file object
				File newFileName = new File(directoryName + "/Log" + id + ".txt");
				createdFile.renameTo(newFileName);
				fileCreated = true;
			}
			//Creates an actual file in the directory
			System.out.println("Path" + createdFile.getAbsolutePath());
			createdFile.createNewFile();
			//Adds 1 to the id then writes it to the first line, this is used to ensure no two logs have the same file number.
			id += 1;
			//Makes the streamwriters for the written log file
			createNewWriter();
			outputStreamWriter.write(id + "\r\n");
			outputStreamWriter.flush();
		}
		//catch any errors
		catch (Exception e) {
			e.printStackTrace();
		}
		catch (IOError e) {
			e.printStackTrace();
		}
	}

	/**
	 * Writes values to file Recommended to start by logging the table heading
	 * names first, polynomial regression tool handles this. If there is a time
	 * when you want to log data but want to ignore something, put null in as the
	 * value in the array (will output a string "null"). Regression calculator
	 * currently cannot handle this exception, as well as data relationships that
	 * have more than 2 variables (y = f(x) type functions) Writes everything as
	 * a string, please convert values to strings before adding them to the
	 * array.
	 * 
	 * @param tableHeadings the array of values to be logged, can be different
	 *                         from the values declared in the setUpLogOnUsb
	 */
	public static void logData(String data) {
		if (useNetworkTables){
			SmartDashboard.putString("DataHandler", data);
		}
		else{
			//Tries writing to the file, adds an error if it doesn't work
			try {
				outputStreamWriter.write(data + "\r\n");
				outputStreamWriter.flush();
			}
			//Catches errors
			catch (Exception e) {
				dataBuffer.add(data);
			}
			catch (IOError e) {
			}
		}
	}

	public static void logData(String[] data) {
		//String that will be output to the writer
		String lineToBeSaved = "";
		//Adds each argument in the array to the string, adds a comma for separation (regression calculator uses this as well)
		for (String heading : data) {
			lineToBeSaved += (heading + ",");
		}
		//Removes last comma at the end
		lineToBeSaved = lineToBeSaved.substring(0, (lineToBeSaved.length() - 1));
		logData(lineToBeSaved);
	}

	public static void logData(int data) {
		String dataString = Integer.toString(data);
		logData(dataString);
	}

	public static void logData(int[] data) {
		String lineToBeSaved = "";
		for (int integer : data) {
			lineToBeSaved += (Integer.toString(integer) + ",");
		}
		lineToBeSaved = lineToBeSaved.substring(0, (lineToBeSaved.length() - 1));
		logData(lineToBeSaved);
	}

	public static void logData(boolean data) {
		String dataString = Boolean.toString(data);
		logData(dataString);
	}

	public static void logData(boolean[] data) {
		String lineToBeSaved = "";
		for (boolean bool : data) {
			lineToBeSaved += (Boolean.toString(bool) + ",");
		}
		lineToBeSaved = lineToBeSaved.substring(0, (lineToBeSaved.length() - 1));
		logData(lineToBeSaved);
	}

	public static void logData(double data) {
		String dataString = Double.toString(data);
		logData(dataString);
	}

	public static void logData(double[] data) {
		String lineToBeSaved = "";
		for (double num : data) {
			lineToBeSaved += (Double.toString(num) + ",");
		}
		lineToBeSaved = lineToBeSaved.substring(0, (lineToBeSaved.length() - 1));
		logData(lineToBeSaved);
	}

	public static void logData(float data) {
		String dataString = Float.toString(data);
		logData(dataString);
	}

	public static void logData(float[] data) {
		String lineToBeSaved = "";
		for (float num : data) {
			lineToBeSaved += (Float.toString(num) + ",");
		}
		lineToBeSaved = lineToBeSaved.substring(0, (lineToBeSaved.length() - 1));
		logData(lineToBeSaved);
	}



	//Basically writes the entire buffer in the event the USB was disconnected. Creates a dump file to store it
	public static void flushBuffer() {
		File dumpFile = new File(
				directoryName + "/Log" + id + "DisconnectDump" + dumpID + ".txt");
		try {
			dumpFile.createNewFile();
			FileOutputStream outputStream = new FileOutputStream(dumpFile);
			OutputStreamWriter dumpFileOutputStreamWriter = new OutputStreamWriter(
					outputStream);
			if (dataBuffer.size() > 0) {
				for (String data : dataBuffer) {
					System.out.println(data);
					dumpFileOutputStreamWriter.write(data + "\r\n");
					dumpFileOutputStreamWriter.flush();
				}
				dataBuffer.clear();
			}
			dumpFileOutputStreamWriter.close();
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Flushes the writer (outputs last value) and then closes it. Does not need
	 * to be called.
	 */
	public static void closeWriter() {
		try {
			outputStreamWriter.flush();
			outputStreamWriter.close();
		}
		//Catches errors
		catch (Exception e) {
			e.printStackTrace();
		}
		catch (IOError e) {
			e.printStackTrace();
		}
	}

	/**
	 * Checks the USB connection status of the RIO by making sure the directory
	 * still exists
	 */
	public static void pingUSB() { isUSBConnected = directory.exists(); }

	/**
	 * Updates the state of the handler, and checks if the USB has been
	 * disconnected. Call this in the periodic function of the file you called
	 * createNewWriter in.
	 */
	public static void updateHandlerState() {
		if (!useNetworkTables){
			pingUSB();
		flushBuffer();
		//If the USB is disconnected and it hasn't closed the writer yet, close it
		if (isUSBConnected == false && debounce == 0) {
			closeWriter();
			debounce = -1;
		}
		//If the USB is reconnected and the writer is closed, open a new one
		else if (isUSBConnected == true && debounce == -1) {

			createLogFileOnRIOUSB();
			debounce = 0;
		}
		//If neither condition is met, do nothing.
		else {
			return;
			}
		}
	}
}